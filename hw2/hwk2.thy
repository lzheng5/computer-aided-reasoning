theory hwk2
  imports Main "HOL.Rat" "HOL-Library.Monad_Syntax"
begin

(* Mostly generated by Claude Opus 4.5 *)

section \<open>Simple Arithmetic Expression Language (SAEL)\<close>
 
text \<open>
  This is an Isabelle/HOL formalization of the ACL2s homework 2 solution.
  It defines a simple arithmetic expression language with error handling
  for division by zero and invalid exponentiation.
\<close>
 
subsection \<open>Data Type Definitions\<close>
 
text \<open>Unary operators: negation and reciprocal\<close>
datatype uoper = UNeg | URecip

text \<open>Binary operators: addition, subtraction, multiplication, division, exponentiation\<close>
datatype boper = BAdd | BSub | BMul | BDiv | BExp
 
text \<open>Variables are represented as strings\<close>
type_synonym var = string
 
text \<open>Simple arithmetic expressions\<close>
datatype saexpr =
    Rat rat                          \<comment> \<open>Rational literal\<close>
  | Var var                          \<comment> \<open>Variable\<close>
  | USaexpr uoper saexpr             \<comment> \<open>Unary expression\<close>
  | BSaexpr saexpr boper saexpr      \<comment> \<open>Binary expression\<close>
 
text \<open>Assignment: mapping from variables to rationals\<close>
type_synonym assignment = "(var \<times> rat) list"
 
subsection \<open>Variable Lookup\<close>
 
text \<open>Look up a variable in an assignment, defaulting to 1 if not found\<close>
fun lookup :: "var \<Rightarrow> assignment \<Rightarrow> rat" where
  "lookup v [] = 1"
| "lookup v ((u, r) # a) = (if u = v then r else lookup v a)"
 
subsection \<open>Expression Evaluation\<close>

text \<open>Helper: convert rational to nat if it's a non-negative integer\<close>
definition rat_to_nat :: "rat \<Rightarrow> nat option" where
  "rat_to_nat r = (if r \<ge> 0 \<and> (\<exists>n. r = of_nat n)
                   then Some (nat \<lfloor>r\<rfloor>)
                   else None)"

text \<open>Apply a unary operator to a value\<close>
fun apply_uoper :: "uoper \<Rightarrow> rat \<Rightarrow> rat option" where
  "apply_uoper UNeg v = Some (- v)"
| "apply_uoper URecip v = (if v = 0 then None else Some (inverse v))"

text \<open>Apply a binary operator to two values\<close>
fun apply_boper :: "boper \<Rightarrow> rat \<Rightarrow> rat \<Rightarrow> rat option" where
  "apply_boper BAdd v0 v1 = Some (v0 + v1)"
| "apply_boper BSub v0 v1 = Some (v0 - v1)"
| "apply_boper BMul v0 v1 = Some (v0 * v1)"
| "apply_boper BDiv v0 v1 = (if v1 = 0 then None else Some (v0 / v1))"
| "apply_boper BExp v0 v1 = (if v0 = 0 then None else do {
    n \<leftarrow> rat_to_nat v1;
    Some (v0 ^ n)
  })"

text \<open>Evaluate a simple arithmetic expression with error handling\<close>
fun saeval :: "saexpr \<Rightarrow> assignment \<Rightarrow> rat option" where
  "saeval (Rat r) a = Some r"
| "saeval (Var v) a = Some (lookup v a)"
| "saeval (USaexpr op e0) a = do {
    v0 \<leftarrow> saeval e0 a;
    apply_uoper op v0
  }"
| "saeval (BSaexpr e0 op e1) a = do {
    v0 \<leftarrow> saeval e0 a;
    v1 \<leftarrow> saeval e1 a;
    apply_boper op v0 v1
  }"
 
subsection \<open>Properties of saeval\<close>
 
text \<open>Evaluation is deterministic (trivial for functions)\<close>
lemma saeval_deterministic: "saeval x a = saeval x a"
  by simp

text \<open>Double negation property\<close>
lemma double_negation [simp]:
  "saeval (USaexpr UNeg (USaexpr UNeg x)) a = saeval x a"
  by (cases "saeval x a") auto

(* lemma double_negation_bad [simp]: *)
(* "saeval (USaexpr UNeg (USaexpr UNeg x)) a = saeval (USaexpr UNeg x) a" *)
(* nitpick *)

lemma double_negation_var:
  "saeval (USaexpr UNeg (USaexpr UNeg (Var x))) a = saeval (Var x) a"
  by auto

text \<open>Triple negation equals single negation\<close>
lemma triple_negation:
  "saeval (USaexpr UNeg (USaexpr UNeg (USaexpr UNeg (Var x)))) a =
   saeval (USaexpr UNeg (Var x)) a"
  by simp
 
text \<open>x + (-y) = x - y\<close>
lemma add_neg_is_sub [simp]:
  "saeval (BSaexpr x BAdd (USaexpr UNeg y)) a =
   saeval (BSaexpr x BSub y) a"
  by (cases "saeval x a"; cases "saeval y a") auto
 
text \<open>1 / (x / y) = y / x when y \<noteq> 0\<close>
lemma recip_property:
  assumes "saeval y a = Some vy"
      and "vy \<noteq> 0"
      and "saeval x a = Some vx"
  shows "saeval (BSaexpr (Rat 1) BDiv (BSaexpr x BDiv y)) a =
         saeval (BSaexpr y BDiv x) a"
  using assms by (simp add: field_simps)

text \<open>Distributivity: x * (y + z) = (x * y) + (x * z)\<close>
lemma distributivity:
  "saeval (BSaexpr x BMul (BSaexpr y BAdd z)) a =
   saeval (BSaexpr (BSaexpr x BMul y) BAdd (BSaexpr x BMul z)) a"
  by (cases "saeval x a"; cases "saeval y a"; cases "saeval z a") 
     (auto simp: field_simps)
 
text \<open>Zero exponent always errors (base is 0)\<close>
lemma zero_exponent_err:
  "saeval (BSaexpr (Rat 0) BExp x) a = None"
  by (cases "saeval x a"; auto)
 
text \<open>Non-zero divide cancellation: (x * y) / y = x when y \<noteq> 0\<close>
lemma non_zero_divide_cancel:
  assumes "saeval y a = Some vy"
      and "vy \<noteq> 0"
  shows "saeval (BSaexpr (BSaexpr (Rat x) BMul y) BDiv y) a = Some x"
  using assms by simp
 
subsection \<open>Alternative Arithmetic Expression (AAExpr) with expt notation\<close>
 
text \<open>Binary operators for AA expressions use 'expt' instead of '^'\<close>
datatype baoper = BAAdd | BASub | BAMul | BADiv | BAExpt
 
text \<open>Alternative arithmetic expressions\<close>
datatype aaexpr =
    ARat rat
  | AVar var
  | UAaexpr uoper aaexpr
  | BAaexpr aaexpr baoper aaexpr

subsection \<open>Translation Functions\<close>

text \<open>Convert binary SAEL operator to AA operator\<close>
fun boper_to_baoper :: "boper \<Rightarrow> baoper" where
  "boper_to_baoper BAdd = BAAdd"
| "boper_to_baoper BSub = BASub"
| "boper_to_baoper BMul = BAMul"
| "boper_to_baoper BDiv = BADiv"
| "boper_to_baoper BExp = BAExpt"

text \<open>Convert binary AA operator to SAEL operator\<close>
fun baoper_to_boper :: "baoper \<Rightarrow> boper" where
  "baoper_to_boper BAAdd = BAdd"
| "baoper_to_boper BASub = BSub"
| "baoper_to_boper BAMul = BMul"
| "baoper_to_boper BADiv = BDiv"
| "baoper_to_boper BAExpt = BExp"

text \<open>Convert SAEL to AA expression\<close>
fun sael_to_aa :: "saexpr \<Rightarrow> aaexpr" where
  "sael_to_aa (Rat r) = ARat r"
| "sael_to_aa (Var v) = AVar v"
| "sael_to_aa (USaexpr op e) = UAaexpr op (sael_to_aa e)"
| "sael_to_aa (BSaexpr e0 op e1) = BAaexpr (sael_to_aa e0) (boper_to_baoper op) (sael_to_aa e1)"
 
text \<open>Convert AA expression to SAEL\<close>
fun aa_to_sael :: "aaexpr \<Rightarrow> saexpr" where
  "aa_to_sael (ARat r) = Rat r"
| "aa_to_sael (AVar v) = Var v"
| "aa_to_sael (UAaexpr op e) = USaexpr op (aa_to_sael e)"
| "aa_to_sael (BAaexpr e0 op e1) = BSaexpr (aa_to_sael e0) (baoper_to_boper op) (aa_to_sael e1)"
 
text \<open>Round-trip property: sael_to_aa \<circ> aa_to_sael = id\<close>
lemma baoper_boper_id [simp] : "boper_to_baoper (baoper_to_boper op) = op"
  by (cases "op"; auto) 

lemma boper_baoper_id [simp]: "baoper_to_boper (boper_to_baoper op) = op"
  by (cases "op"; auto) 

lemma sael_aa_id [simp] : "sael_to_aa (aa_to_sael e) = e"
  by (induction e rule: aa_to_sael.induct) auto
  
text \<open>Round-trip property: aa_to_sael \<circ> sael_to_aa = id\<close>
lemma aa_sael_id [simp] : "aa_to_sael (sael_to_aa e) = e"
  apply (induct_tac e rule: sael_to_aa.induct, auto) 
  done

subsection \<open>AA Expression Evaluation (Total, No Errors)\<close>

text \<open>Apply a unary operator to a value (total version for aaeval)\<close>
fun aapply_uoper :: "uoper \<Rightarrow> rat \<Rightarrow> rat" where
  "aapply_uoper UNeg v = - v"
| "aapply_uoper URecip v = (if v = 0 then 0 else inverse v)"

text \<open>Apply a binary AA operator to two values (total version for aaeval)\<close>
fun aapply_baoper :: "baoper \<Rightarrow> rat \<Rightarrow> rat \<Rightarrow> rat" where
  "aapply_baoper BAAdd v0 v1 = v0 + v1"
| "aapply_baoper BASub v0 v1 = v0 - v1"
| "aapply_baoper BAMul v0 v1 = v0 * v1"
| "aapply_baoper BADiv v0 v1 = (if v1 = 0 then 0 else v0 / v1)"
| "aapply_baoper BAExpt v0 v1 = (if v0 = 0 then 0 else
    (case rat_to_nat v1 of None \<Rightarrow> 1 | Some n \<Rightarrow> v0 ^ n))"

text \<open>Evaluate AA expression (total function, returns 0 or 1 for error cases)\<close>
fun aaeval :: "aaexpr \<Rightarrow> assignment \<Rightarrow> rat" where
  "aaeval (ARat r) a = r"
| "aaeval (AVar v) a = lookup v a"
| "aaeval (UAaexpr op e0) a = aapply_uoper op (aaeval e0 a)"
| "aaeval (BAaexpr e0 op e1) a = aapply_baoper op (aaeval e0 a) (aaeval e1 a)"
 
subsection \<open>Equivalence Between saeval and aaeval\<close>

text \<open>When saeval succeeds, aaeval produces the same result\<close>
lemma saeval_aaeval_equiv:
  assumes "saeval e a = Some v"
  shows "aaeval (sael_to_aa e) a = v"
  using assms
proof (induction e arbitrary: v)
  case (Rat r)
  then show ?case by simp
next
  case (Var x)
  then show ?case by simp
next
  case (USaexpr op e0)
  then show ?case
    by (cases op; cases "saeval e0 a")        
       (auto split: option.splits if_splits)
next
  case (BSaexpr e0 op e1)
  then show ?case
    by (cases op; cases "saeval e0 a"; cases "saeval e1 a") 
       (auto split: option.splits if_splits)
qed

text \<open>When the translation's saeval succeeds, aaeval agrees\<close>
lemma aaeval_saeval_equiv:
  assumes "saeval (aa_to_sael e) a = Some v"
  shows "aaeval e a = v"
proof -
  have "aaeval (sael_to_aa (aa_to_sael e)) a = v"
    using assms saeval_aaeval_equiv by blast
  then show ?thesis
    using sael_aa_id by simp
qed

lemma aaeval_saeval_equiv2:
  assumes "saeval (aa_to_sael e) a = Some v"
  shows "aaeval e a = v"
  using assms saeval_aaeval_equiv sael_aa_id 
  (* sledgehammer *)
  by metis

end