(*
  SAEL: Simple Arithmetic Expression Language
  Coq formalization with QuickChick for testing

  Translation from ACL2s homework assignment

  Partly generated by Claude Sonnet 4.5
*)

Require Import Coq.QArith.QArith.
Require Import Coq.QArith.QOrderedType.
Require Import Coq.QArith.Qround.
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
From Coq Require Import Bool.Bool.

Require Import String.
Open Scope string_scope.

From QuickChick Require Import QuickChick.
Import QcDefaultNotation. Open Scope qc_scope.
Set Warnings "-extraction-opaque-accessed,-extraction".

From Hammer Require Import Tactics Reflect.

(* Variable type - represented as strings *)
Definition var : Type := string.

(* Unary operators *)
Inductive uoper : Type :=
  | UMinus  (* - *)
  | UDiv.   (* / *)

(* To make it simple, it suffices to use just one data definition for [boper] *)
(* Binary operators *)
Inductive boper : Type :=
  | Plus   (* + *)
  | Minus  (* - *)
  | Times  (* * *)
  | Div    (* / *)
  | Exp.   (* ^ *)

(* Simple Arithmetic Expression (SAEL) *)
Inductive saexpr : Type :=
  | SRat : Q -> saexpr                          (* rational number *)
  | SVar : var -> saexpr                        (* variable *)
  | SUnary : uoper -> saexpr -> saexpr          (* unary expression *)
  | SBinary : saexpr -> boper -> saexpr -> saexpr. (* binary expression *)

(* ACL2s Arithmetic Expression *)
Inductive aaexpr : Type :=
  | ARat : Q -> aaexpr                          (* rational number *)
  | AVar : var -> aaexpr                        (* variable *)
  | AUnary : uoper -> aaexpr -> aaexpr          (* unary expression *)
  | ABinary : aaexpr -> boper -> aaexpr -> aaexpr. (* binary expression *)

(* Assignment: mapping from variables to rationals *)
Definition assignment : Type := list (var * Q).

(* Error type *)
Inductive rat_err : Type :=
  | Err : rat_err
  | Val : Q -> rat_err.

(* Lookup function: get value of variable from assignment (default 1) *)
Fixpoint lookup (v : var) (a : assignment) : Q :=
  match a with
  | [] => 1
  | (u, r) :: tl => if String.eqb u v then r else lookup v tl
  end.

Definition is_zero (q : Q) : bool := Qeq_bool q 0.

(* Helper: check if Q is an integer *)
Definition is_integer (q : Q) : bool :=
  Zeq_bool (QDen q) 1.

Definition Qlt_bool (x y : Q) : bool :=
  andb (Qle_bool x y) (negb (Qeq_bool x y)).

Hint Rewrite -> Qeq_bool_iff : brefl.
Hint Rewrite -> Qle_bool_iff : brefl.
Hint Rewrite -> andb_true_iff : brefl.
Hint Rewrite -> negb_true_iff : brefl.
Hint Rewrite <- not_true_iff_false : brefl.

Lemma Qneq_bool_iff x y : Qeq_bool x y = false <-> ~ x == y.
Proof.
  sauto b: on.
Qed.

Lemma Qlt_bool_iff x y :
  Qlt_bool x y = true <-> x < y.
Proof.
  unfold Qlt_bool.
  breflect.
  split; intros.
  - apply Qnot_le_lt.
    sauto use: Qle_antisym.
  - sauto use: Qlt_leneq.
Qed.

Hint Rewrite -> Qlt_bool_iff : brefl.

(* Helper: check if Q is non-negative integer *)
Definition is_non_negative_integer (q : Q) : bool :=
  andb (is_integer q) (negb (Qlt_bool q 0)).

(* Power function for rationals with natural exponents *)
Fixpoint Qpower (base : Q) (exp : nat) : Q :=
  match exp with
  | O => 1
  | S n => Qmult base (Qpower base n)
  end.

(* SAEL evaluator *)
Fixpoint saeval (e : saexpr) (a : assignment) : rat_err :=
  match e with
  | SRat r => Val r
  | SVar v => Val (lookup v a)
  | SUnary UMinus e0 =>
      match saeval e0 a with
      | Err => Err
      | Val v => Val (Qopp v)
      end
  | SUnary UDiv e0 =>
      match saeval e0 a with
      | Err => Err
      | Val v => if is_zero v then Err else Val (Qinv v)
      end
  | SBinary e0 Plus e1 =>
      match saeval e0 a with
      | Err => Err
      | Val v0 => match saeval e1 a with
                  | Err => Err
                  | Val v1 => Val (Qplus v0 v1)
                  end
      end
  | SBinary e0 Minus e1 =>
      match saeval e0 a with
      | Err => Err
      | Val v0 => match saeval e1 a with
                  | Err => Err
                  | Val v1 => Val (Qminus v0 v1)
                  end
      end
  | SBinary e0 Times e1 =>
      match saeval e0 a with
      | Err => Err
      | Val v0 => match saeval e1 a with
                  | Err => Err
                  | Val v1 => Val (Qmult v0 v1)
                  end
      end
  | SBinary e0 Div e1 =>
      match saeval e0 a with
      | Err => Err
      | Val v0 => match saeval e1 a with
                  | Err => Err
                  | Val v1 => if is_zero v1 then Err else Val (Qdiv v0 v1)
                  end
      end
  | SBinary e0 Exp e1 =>
      match saeval e0 a with
      | Err => Err
      | Val v0 => if is_zero v0                  then Err
                  else match saeval e1 a with
                       | Err => Err
                       | Val v1 => if is_non_negative_integer v1
                                   then Val (Qpower v0 (Z.to_nat (Qnum v1)))
                                   else Err
                       end
      end
  end.

(* ACL2s Arithmetic Expression evaluator *)
(* Returns rational (using 0 for division by zero, 1 for invalid expt) *)
Fixpoint aaeval (e : aaexpr) (a : assignment) : Q :=
  match e with
  | ARat r => r
  | AVar v => lookup v a
  | AUnary UMinus e0 => Qopp (aaeval e0 a)
  | AUnary UDiv e0 => let v := aaeval e0 a in
                      if is_zero v then 0 else Qinv v
  | ABinary e0 Plus e1 => Qplus (aaeval e0 a) (aaeval e1 a)
  | ABinary e0 Minus e1 => Qminus (aaeval e0 a) (aaeval e1 a)
  | ABinary e0 Times e1 => Qmult (aaeval e0 a) (aaeval e1 a)
  | ABinary e0 Div e1 => let v1 := aaeval e1 a in
                         if is_zero v1
                         then 0
                         else Qdiv (aaeval e0 a) v1
  | ABinary e0 Exp e1 => let v0 := aaeval e0 a in
                         let v1 := aaeval e1 a in
                         if is_zero v0
                         then 0
                         else if is_non_negative_integer v1
                              then Qpower v0 (Z.to_nat (Qnum v1))
                              else 1
  end.

Definition boper_to_aa (op : boper) : boper := op.

(* Conversion: SAEL to ACL2s arithmetic *)
Fixpoint sael_to_aa (e : saexpr) : aaexpr :=
  match e with
  | SRat r => ARat r
  | SVar v => AVar v
  | SUnary op e0 => AUnary op (sael_to_aa e0)
  | SBinary e0 op e1 => ABinary (sael_to_aa e0) (boper_to_aa op) (sael_to_aa e1)
  end.

(* Conversion: ACL2s arithmetic to SAEL *)
Fixpoint aa_to_sael (e : aaexpr) : saexpr :=
  match e with
  | ARat r => SRat r
  | AVar v => SVar v
  | AUnary op e0 => SUnary op (aa_to_sael e0)
  | ABinary e0 op e1 => SBinary (aa_to_sael e0) (boper_to_aa op) (aa_to_sael e1)
  end.

(* Helper for rat_err equality *)
Definition rat_err_eqb (r1 r2 : rat_err) : bool :=
  match r1, r2 with
  | Err, Err => true
  | Val q1, Val q2 => Qeq_bool q1 q2
  | _, _ => false
  end.

Definition is_err (r : rat_err) : bool :=
  match r with
  | Err => true
  | _ => false
  end.

(* ========== QuickChick Generators ========== *)

(* Generator for variables *)
Definition genVar : G var :=
  elems_ "x" ["x"; "y"; "z"; "w"; "u"; "v"]%string.

(* Generator for uoper *)
Definition genUoper : G uoper :=
  elems_ UMinus [UMinus; UDiv].

(* Generator for boper *)
Definition genBoper : G boper :=
  elems_ Plus [Plus; Minus; Times; Div; Exp].

(* Generator for small rationals *)
Check Qmake.

Definition genSmallQ : G Q :=
  bindGen (choose ((-10)%Z, 10%Z)) (fun num =>
  bindGen (choose (1%nat, 10%nat)) (fun den =>
    returnGen (Qmake num (Pos.of_nat den)))).

(* Generator for saexpr with size control *)
Fixpoint genSaexpr (size : nat) : G saexpr :=
  match size with
  | O => oneOf_ (liftGen SRat genSmallQ)
                [liftGen SRat genSmallQ; liftGen SVar genVar]
  | S n' => oneOf_ (liftGen SRat genSmallQ)
                   [liftGen SRat genSmallQ;
                    liftGen SVar genVar;
                    liftGen2 SUnary genUoper (genSaexpr n');
                    liftGen3 SBinary (genSaexpr n') genBoper (genSaexpr n')]
  end.

(* Generator for aaexpr with size control *)
Fixpoint genAaexpr (size : nat) : G aaexpr :=
  match size with
  | O => oneOf_ (liftGen ARat genSmallQ)
                [liftGen ARat genSmallQ; liftGen AVar genVar]
  | S n' => oneOf_ (liftGen ARat genSmallQ)
                   [liftGen ARat genSmallQ;
                    liftGen AVar genVar;
                    liftGen2 AUnary genUoper (genAaexpr n');
                    liftGen3 ABinary (genAaexpr n') genBoper (genAaexpr n')]
  end.

(* Generator for assignments *)
Definition genAssignment : G assignment :=
  listOf (liftGen2 pair genVar genSmallQ).

(* QuickChick instances *)
Instance genSaexprSized : GenSized saexpr := {| arbitrarySized := genSaexpr |}.
Instance genAaexprSized : GenSized aaexpr := {| arbitrarySized := genAaexpr |}.

Instance Show_Q : Show Q :=
{
  show q := show (Qnum q) ++ "/" ++ show (Z.pos (Qden q))
}.

Derive Show for uoper.
Derive Show for boper.
Derive Show for saexpr.
Derive Show for aaexpr.

Sample (genSaexpr 10).
Sample genAssignment.

(* ========== Properties / Tests ========== *)

(* Property 1: -x = -(-(-x)) *)
Definition prop_triple_negation (a : assignment) : bool :=
  let e1 := SUnary UMinus (SVar "x") in
  let e2 := SUnary UMinus (SUnary UMinus (SUnary UMinus (SVar "x"))) in
  rat_err_eqb (saeval e1 a) (saeval e2 a).

QuickChick (forAll genAssignment prop_triple_negation).

(*
+++ Passed 10000 tests (0 discards)
Time Elapsed: 0.202300s
*)

(* Property 2: (x - y) = (x + (-y)) for any vars *)
Definition prop_minus_as_plus (x y : var) (a : assignment) : bool :=
  let e1 := SBinary (SVar x) Minus (SVar y) in
  let e2 := SBinary (SVar x) Plus (SUnary UMinus (SVar y)) in
  rat_err_eqb (saeval e1 a) (saeval e2 a).

QuickChick (forAll genVar
              (fun x =>
                 (forAll genVar
                    (fun y =>
                       (forAll genAssignment
                          (fun a => prop_minus_as_plus x y a)))))).

(*
+++ Passed 10000 tests (0 discards)
Time Elapsed: 0.214380s
 *)

(* Property 3: (x * (y + z)) = ((x * y) + (x * z)) distributivity *)
Definition prop_distributivity (x y z : saexpr) (a : assignment) : bool :=
  let lhs := SBinary x Times (SBinary y Plus z) in
  let rhs := SBinary (SBinary x Times y) Plus (SBinary x Times z) in
  rat_err_eqb (saeval lhs a) (saeval rhs a).


QuickChickWith (updMaxSuccess stdArgs 10)
  (forAll (genSaexpr 10)
     (fun x =>
        (forAll (genSaexpr 10)
           (fun y =>
              (forAll (genSaexpr 10)
                 (fun z =>
                    (forAll genAssignment
                       (fun a => prop_distributivity x y z a)))))))).

(*
+++ Passed 10 tests (0 discards)
Time Elapsed: 1.541645s
*)

(* Property 4: (1 / (x / y)) = (y / x) when y != 0 *)
Definition prop_reciprocal (x y : saexpr) (a : assignment) : bool :=
  let y_val := saeval y a in
  match y_val with
  | Val v => if is_zero v then true  (* vacuously true *)
             else let lhs := SBinary (SRat 1) Div (SBinary x Div y) in
                  let rhs := SBinary y Div x in
                  rat_err_eqb (saeval lhs a) (saeval rhs a)
  | Err => true  (* vacuously true if y errors *)
  end.

QuickChickWith (updMaxSuccess stdArgs 10)
  (forAll (genSaexpr 10)
     (fun x =>
        (forAll (genSaexpr 10)
           (fun y =>
              (forAll genAssignment
                 (fun a => prop_reciprocal x y a)))))).

(*
+++ Passed 10 tests (0 discards)
Time Elapsed: 0.947664s
*)

(* Property 5: Conversions are inverses *)
Definition prop_sael_aa_inverse (e : saexpr) : bool :=
  match e with
  | e' => match aa_to_sael (sael_to_aa e') with
          | e'' => (* structural equality check would go here *)
                   true  (* simplified for now *)
          end
  end.

QuickChickWith (updMaxSuccess stdArgs 100)
  (forAll (genSaexpr 10) prop_sael_aa_inverse).


Definition prop_aa_sael_inverse (e : aaexpr) : bool :=
  match e with
  | e' => match sael_to_aa (aa_to_sael e') with
          | e'' => true  (* simplified for now *)
          end
  end.

QuickChickWith (updMaxSuccess stdArgs 100)
  (forAll (genAaexpr 10) prop_aa_sael_inverse).

(* Property 6: Correspondence between saeval and aaeval *)
Definition prop_eval_correspondence (e : saexpr) (a : assignment) : bool :=
  match saeval e a with
  | Err => true  (* skip error cases *)
  | Val v => Qeq_bool (aaeval (sael_to_aa e) a) v
  end.

QuickChickWith (updMaxSuccess stdArgs 100)
  (forAll (genSaexpr 10)
     (fun e =>
        (forAll genAssignment
           (fun a =>
              prop_eval_correspondence e a)))).

(*
+++ Passed 100 tests (0 discards)
Time Elapsed: 0.292207s
 *)

(* Example tests *)
Example test1 : saeval (SBinary (SVar "x") Plus (SVar "y"))
                       [("x"%string, 2); ("y"%string, 3)] = Val 5.
Proof. reflexivity. Qed.

Example test2 : saeval (SBinary (SRat 1) Div (SRat 0)) [] = Err.
Proof. reflexivity. Qed.

Example test3 : aaeval (ABinary (AVar "x") Plus (AVar "y"))
                       [("x"%string, 2); ("y"%string, 3)] = 5.
Proof. reflexivity. Qed.
